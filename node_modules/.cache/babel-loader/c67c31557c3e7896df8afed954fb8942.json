{"ast":null,"code":"import { useId as e } from \"@radix-ui/react-id\";\nimport * as t from \"@radix-ui/react-visually-hidden\";\nimport { Slottable as o } from \"@radix-ui/react-slot\";\nimport { Portal as n } from \"@radix-ui/react-portal\";\nimport * as r from \"@radix-ui/react-popper\";\nimport { createPopperScope as i } from \"@radix-ui/react-popper\";\nimport { Primitive as a } from \"@radix-ui/react-primitive\";\nimport { Presence as s } from \"@radix-ui/react-presence\";\nimport { useRect as l } from \"@radix-ui/react-use-rect\";\nimport { usePrevious as c } from \"@radix-ui/react-use-previous\";\nimport { useLayoutEffect as p } from \"@radix-ui/react-use-layout-effect\";\nimport { useEscapeKeydown as u } from \"@radix-ui/react-use-escape-keydown\";\nimport { useControllableState as d } from \"@radix-ui/react-use-controllable-state\";\nimport { createContextScope as m } from \"@radix-ui/react-context\";\nimport { useComposedRefs as f } from \"@radix-ui/react-compose-refs\";\nimport { composeEventHandlers as g } from \"@radix-ui/primitive\";\nimport * as E from \"react\";\nimport x from \"@babel/runtime/helpers/esm/extends\";\n\nfunction y(e) {\n  return {\n    type: \"machine.actions.assign\",\n    assign: e\n  };\n}\n\nlet T, C;\n\nconst v = y((e, t) => {\n  var o;\n  return { ...e,\n    id: null !== (o = t.id) && void 0 !== o ? o : e.id\n  };\n}),\n      _ = function (e) {\n  let {\n    debug: t = !1,\n    warnOnUnknownTransitions: o = !1\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let n = e.initial,\n      r = e.context;\n\n  const i = [],\n        a = s => {\n    var l, c;\n    const p = e.states[n],\n          u = s.type,\n          d = null === (l = e.on) || void 0 === l ? void 0 : l[u],\n          m = null === (c = p.on) || void 0 === c ? void 0 : c[u],\n          f = null != d ? d : m;\n    if (void 0 === f) o && console.warn(`From state: \"${n}\", event \"${u}\" has no transition to any state`);else {\n      const {\n        target: o,\n        actions: l = [],\n        cond: c = () => !0\n      } = f,\n            u = o ? e.states[o] : {};\n\n      if (c(r, s)) {\n        const e = (p.exit || []).concat(l, u.entry || []);\n        r = function (e, t, o) {\n          let n = o;\n          return null == e || e.forEach(e => {\n            \"function\" == typeof e ? e(n, t, a) : \"machine.actions.assign\" === e.type && (n = e.assign(n, t));\n          }), n;\n        }(e, s, r), o && (n = o, t && (console.group(\"event:\", s), console.log(\"state:\", n), console.log(\"context:\", r), console.groupEnd()), i.forEach(e => e({\n          state: n,\n          context: r\n        })));\n      }\n    }\n  };\n\n  return {\n    subscribe: function (e) {\n      return i.push(e), () => {\n        i.splice(i.indexOf(e), 1);\n      };\n    },\n    send: a,\n    getContext: function () {\n      return r;\n    }\n  };\n}({\n  initial: \"closed\",\n  context: {\n    id: null,\n    delayed: !1\n  },\n  on: {\n    FOCUS: {\n      target: \"open\"\n    }\n  },\n  states: {\n    closed: {\n      entry: [y(e => ({ ...e,\n        id: null\n      }))],\n      on: {\n        OPEN: {\n          target: \"opening\"\n        }\n      }\n    },\n    opening: {\n      entry: [(e, t, o) => {\n        const n = t.delayDuration,\n              r = () => o({\n          type: \"DELAY_TIMER_END\"\n        });\n\n        void 0 === n ? r() : T = window.setTimeout(r, n);\n      }, v, y(e => ({ ...e,\n        delayed: !0\n      }))],\n      exit: [() => clearTimeout(T)],\n      on: {\n        DELAY_TIMER_END: {\n          target: \"open\"\n        },\n        CLOSE: {\n          target: \"closed\"\n        }\n      }\n    },\n    open: {\n      entry: [v],\n      exit: [y(e => ({ ...e,\n        delayed: !1\n      }))],\n      on: {\n        OPEN: {\n          target: \"open\"\n        },\n        CLOSE: {\n          target: \"closing\",\n          cond: (e, t) => e.id === t.id\n        }\n      }\n    },\n    closing: {\n      entry: [(e, t, o) => {\n        var n;\n        const r = null !== (n = t.skipDelayDuration) && void 0 !== n ? n : 300;\n        C = window.setTimeout(() => o({\n          type: \"SKIP_DELAY_TIMER_END\"\n        }), r);\n      }],\n      exit: [() => clearTimeout(C)],\n      on: {\n        OPEN: {\n          target: \"open\"\n        },\n        SKIP_DELAY_TIMER_END: {\n          target: \"closed\"\n        }\n      }\n    }\n  }\n}),\n      [b, D] = m(\"Tooltip\", [i]);\n\nexport { D as createTooltipScope };\nconst w = i(),\n      [h, O] = b(\"Tooltip\");\nexport const Tooltip = t => {\n  const {\n    __scopeTooltip: o,\n    children: n,\n    open: i,\n    defaultOpen: a = !1,\n    onOpenChange: s,\n    delayDuration: l = 700,\n    skipDelayDuration: c = 300\n  } = t,\n        u = w(o),\n        [m, f] = E.useState(null),\n        g = e(),\n        [x = !1, y] = d({\n    prop: i,\n    defaultProp: a,\n    onChange: s\n  }),\n        [T, C] = E.useState(i ? \"instant-open\" : \"closed\");\n  E.useEffect(() => _.subscribe(_ref => {\n    let {\n      state: e,\n      context: t\n    } = _ref;\n    \"open\" === e && t.id === g ? y(!0) : y(!1);\n  }), [g, y]), E.useEffect(() => _.subscribe(_ref2 => {\n    let {\n      state: e,\n      context: t\n    } = _ref2;\n    t.id === g ? C(\"open\" === e ? t.delayed ? \"delayed-open\" : \"instant-open\" : \"closed\") : C(\"closed\");\n  }), [g]);\n  const v = E.useCallback(() => _.send({\n    type: \"FOCUS\",\n    id: g\n  }), [g]),\n        b = E.useCallback(() => _.send({\n    type: \"OPEN\",\n    id: g,\n    delayDuration: l\n  }), [g, l]),\n        D = E.useCallback(() => _.send({\n    type: \"CLOSE\",\n    id: g,\n    skipDelayDuration: c\n  }), [c, g]);\n  return E.useEffect(() => () => D(), [D]), p(() => {\n    !0 === i && _.send({\n      type: \"OPEN\",\n      id: g\n    });\n  }, [g, i]), /*#__PURE__*/E.createElement(r.Root, u, /*#__PURE__*/E.createElement(h, {\n    scope: o,\n    contentId: g,\n    open: x,\n    stateAttribute: T,\n    trigger: m,\n    onTriggerChange: f,\n    onFocus: v,\n    onOpen: b,\n    onClose: D\n  }, n));\n};\n/*#__PURE__*/\n\nexport const TooltipTrigger = /*#__PURE__*/E.forwardRef((e, t) => {\n  const {\n    __scopeTooltip: o,\n    ...n\n  } = e,\n        i = O(\"TooltipTrigger\", o),\n        s = w(o),\n        l = f(t, i.onTriggerChange);\n  /*#__PURE__*/\n\n  return E.createElement(r.Anchor, x({\n    asChild: !0\n  }, s), /*#__PURE__*/E.createElement(a.button, x({\n    type: \"button\",\n    \"aria-describedby\": i.open ? i.contentId : void 0,\n    \"data-state\": i.stateAttribute\n  }, n, {\n    ref: l,\n    onMouseEnter: g(e.onMouseEnter, i.onOpen),\n    onMouseLeave: g(e.onMouseLeave, i.onClose),\n    onMouseDown: g(e.onMouseDown, i.onClose),\n    onFocus: g(e.onFocus, i.onFocus),\n    onBlur: g(e.onBlur, i.onClose),\n    onKeyDown: g(e.onKeyDown, e => {\n      \"Enter\" !== e.key && \" \" !== e.key || i.onClose();\n    })\n  })));\n});\n/*#__PURE__*/\n\nexport const TooltipContent = /*#__PURE__*/E.forwardRef((e, t) => {\n  const {\n    forceMount: o,\n    ...n\n  } = e,\n        r = O(\"TooltipContent\", e.__scopeTooltip);\n  /*#__PURE__*/\n\n  return E.createElement(s, {\n    present: o || r.open\n  }, /*#__PURE__*/E.createElement(A, x({\n    ref: t\n  }, n)));\n});\nconst A = /*#__PURE__*/E.forwardRef((e, i) => {\n  const {\n    __scopeTooltip: a,\n    children: s,\n    \"aria-label\": l,\n    portalled: c = !0,\n    ...p\n  } = e,\n        d = O(\"TooltipContent\", a),\n        m = w(a),\n        f = c ? n : E.Fragment;\n  return u(() => d.onClose()), /*#__PURE__*/E.createElement(f, null, /*#__PURE__*/E.createElement(M, {\n    __scopeTooltip: a\n  }), /*#__PURE__*/E.createElement(r.Content, x({\n    \"data-state\": d.stateAttribute\n  }, m, p, {\n    ref: i,\n    style: { ...p.style,\n      \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\"\n    }\n  }), /*#__PURE__*/E.createElement(o, null, s), /*#__PURE__*/E.createElement(t.Root, {\n    id: d.contentId,\n    role: \"tooltip\"\n  }, l || s)));\n});\n/*#__PURE__*/\n\nexport const TooltipArrow = /*#__PURE__*/E.forwardRef((e, t) => {\n  const {\n    __scopeTooltip: o,\n    ...n\n  } = e,\n        i = w(o);\n  /*#__PURE__*/\n\n  return E.createElement(r.Arrow, x({}, i, n, {\n    ref: t\n  }));\n});\n/*#__PURE__*/\n\nfunction M(e) {\n  const {\n    __scopeTooltip: t\n  } = e,\n        o = O(\"CheckTriggerMoved\", t),\n        n = l(o.trigger),\n        r = null == n ? void 0 : n.left,\n        i = c(r),\n        a = null == n ? void 0 : n.top,\n        s = c(a),\n        p = o.onClose;\n  return E.useEffect(() => {\n    (void 0 !== i && i !== r || void 0 !== s && s !== a) && p();\n  }, [p, i, s, r, a]), null;\n}\n\nexport const Root = Tooltip;\nexport const Trigger = TooltipTrigger;\nexport const Content = TooltipContent;\nexport const Arrow = TooltipArrow;","map":{"version":3,"sources":["packages/react/tooltip/src/createStateMachine.tsx","packages/react/tooltip/src/tooltipStateChart.tsx","packages/react/tooltip/src/Tooltip.tsx"],"names":["stateChart","debug","warnOnUnknownTransitions","currentState","initial","currentContext","context","subscriptions","callback","push","splice","indexOf","forEach","state","send","event","stateDefinition","states","type","topLevelTransition","on","stateTransition","transition","undefined","console","warn","actions","target","nextState","cond","nextStateDefinition","allActions","exit","concat","entry","executeActions","group","log","groupEnd","nextContext","action","assign","subscribe","getContext","assignFn","delayTimerId","skipDelayTimerId","delayDuration","sendTimerEnd","window","setTimeout","clearTimeout","skipDelayDuration","setId","$ef54466d8a95ecaa234e3ec978fbe68$export$assign","id","delayed","FOCUS","closed","OPEN","opening","DELAY_TIMER_END","CLOSE","open","closing","SKIP_DELAY_TIMER_END","stateMachine","$ef54466d8a95ecaa234e3ec978fbe68$export$createStateMachine","createTooltipContext","createTooltipScope","createContextScope","createPopperScope","usePopperScope","TooltipProvider","useTooltipContext","Tooltip","props","__scopeTooltip","children","openProp","defaultOpen","onOpenChange","popperScope","trigger","setTrigger","React","useState","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useEffect","handleFocus","useCallback","handleOpen","handleClose","useLayoutEffect","_react","_radixUiReactPopper","Root","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","scope","onTriggerChange","onFocus","onOpen","onClose","TooltipTrigger","forwardRef","forwardedRef","triggerProps","composedTriggerRef","useComposedRefs","Anchor","asChild","Primitive","button","ref","onMouseEnter","composeEventHandlers","onMouseLeave","onMouseDown","onBlur","onKeyDown","key","TooltipContent","forceMount","contentProps","Presence","present","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","portalled","PortalWrapper","Portal","Fragment","useEscapeKeydown","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","Content","style","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","arrowProps","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger"],"mappings":"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","sourcesContent":["const ASSIGN_ACTION_TYPE = 'machine.actions.assign' as const;\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\ntype StateChart<State extends string, Context, Event extends { type: string }> = {\n  initial: State;\n  context: Context;\n  on?: {\n    [eventType in Event['type']]?: Transition<State, Context, Event>;\n  };\n  states: {\n    [stateValue in State]: {\n      on?: {\n        [eventType in Event['type']]?: Transition<State, Context, Event>;\n      };\n      entry?: Array<Action<Context, Event>>;\n      exit?: Array<Action<Context, Event>>;\n    };\n  };\n};\n\ntype Transition<State extends string, Context, Event> = {\n  target?: State;\n  actions?: Array<Action<Context, Event>>;\n  cond?: (context: Context, Event: Event) => boolean;\n};\n\ntype Action<Context, Event> = ActionFunction<Context, Event> | AssignAction<Context, Event>;\n\ntype ActionFunction<Context, Event> = (\n  context: Context,\n  event: Event,\n  send: (event: Event) => void\n) => void;\n\nfunction createStateMachine<State extends string, Context, Event extends { type: string }>(\n  stateChart: StateChart<State, Context, Event>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let currentState = stateChart.initial;\n  let currentContext = stateChart.context;\n\n  type CallbackFn = (args: { state: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) => callback({ state: currentState, context: currentContext }));\n  }\n\n  const send = (event: Event) => {\n    const stateDefinition = stateChart.states[currentState];\n    const type: Event['type'] | undefined = event.type;\n    const topLevelTransition: Transition<State, Context, Event> | undefined = stateChart.on?.[type];\n    const stateTransition: Transition<State, Context, Event> | undefined =\n      stateDefinition.on?.[type];\n    const transition = topLevelTransition ?? stateTransition;\n\n    if (transition === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(\n          `From state: \"${currentState}\", event \"${type}\" has no transition to any state`\n        );\n      }\n    } else {\n      const { target: nextState, actions = [], cond = () => true } = transition;\n      const nextStateDefinition = nextState ? stateChart.states[nextState] : {};\n\n      if (cond(currentContext, event)) {\n        // execute actions\n        const allActions = (stateDefinition.exit || []).concat(\n          actions,\n          nextStateDefinition.entry || []\n        );\n        currentContext = executeActions(allActions, event, currentContext);\n\n        if (nextState) {\n          currentState = nextState;\n\n          if (debug) {\n            console.group('event:', event);\n            console.log('state:', currentState);\n            console.log('context:', currentContext);\n            console.groupEnd();\n          }\n\n          notify();\n        }\n      }\n    }\n  };\n\n  function getContext() {\n    return currentContext;\n  }\n\n  function executeActions(\n    actions: Array<Action<Context, Event>>,\n    event: Event,\n    context: Context\n  ): Context {\n    let nextContext = context;\n    actions?.forEach((action) => {\n      if (typeof action === 'function') {\n        action(nextContext, event, send);\n      } else if (action.type === ASSIGN_ACTION_TYPE) {\n        nextContext = action.assign(nextContext, event);\n      }\n    });\n    return nextContext;\n  }\n\n  return { subscribe, send, getContext };\n}\n\ntype AssignAction<Context, Event> = {\n  type: typeof ASSIGN_ACTION_TYPE;\n  assign(context: Context, event: Event): Context;\n};\n\nfunction assign<Context, Event>(\n  assignFn: AssignAction<Context, Event>['assign']\n): AssignAction<Context, Event> {\n  return { type: ASSIGN_ACTION_TYPE, assign: assignFn };\n}\n\nexport { createStateMachine, assign };\nexport type { StateChart, Action };\n","import { assign } from './createStateMachine';\n\nimport type { StateChart, Action } from './createStateMachine';\n\ntype TooltipState = 'closed' | 'opening' | 'open' | 'closing';\n\ntype TooltipEvent =\n  | { type: 'OPEN'; id: string; delayDuration?: number }\n  | { type: 'CLOSE'; id: string; skipDelayDuration: number }\n  | { type: 'FOCUS'; id: string }\n  | { type: 'DELAY_TIMER_END' }\n  | { type: 'SKIP_DELAY_TIMER_END' };\n\ntype TooltipContext = { id: string | null; delayed: boolean };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipContext, TooltipEvent>;\ntype TooltipAction = Action<TooltipContext, TooltipEvent>;\n\n// actions\nlet delayTimerId: number;\nlet skipDelayTimerId: number;\n\nconst startDelayTimer: TooltipAction = (context, event, send) => {\n  const delayDuration: number | undefined = (event as any).delayDuration;\n  const sendTimerEnd = () => send({ type: 'DELAY_TIMER_END' });\n  if (delayDuration === undefined) {\n    sendTimerEnd();\n  } else {\n    delayTimerId = window.setTimeout(sendTimerEnd, delayDuration);\n  }\n};\n\nconst cancelDelayTimer: TooltipAction = () => clearTimeout(delayTimerId);\n\nconst startSkipDelayTimer: TooltipAction = (context, event, send) => {\n  const skipDelayDuration: number = (event as any).skipDelayDuration ?? 300;\n  skipDelayTimerId = window.setTimeout(\n    () => send({ type: 'SKIP_DELAY_TIMER_END' }),\n    skipDelayDuration\n  );\n};\n\nconst cancelSkipDelayTimer: TooltipAction = () => clearTimeout(skipDelayTimerId);\n\nconst setId: TooltipAction = assign((context, event) => ({\n  ...context,\n  id: (event as any).id ?? context.id,\n}));\nconst resetId: TooltipAction = assign((context) => ({ ...context, id: null }));\nconst setDelayed: TooltipAction = assign((context) => ({ ...context, delayed: true }));\nconst resetDelayed: TooltipAction = assign((context) => ({ ...context, delayed: false }));\n\nconst tooltipStateChart: TooltipStateChart = {\n  initial: 'closed',\n  context: { id: null, delayed: false },\n  on: {\n    FOCUS: { target: 'open' },\n  },\n  states: {\n    closed: {\n      entry: [resetId],\n      on: {\n        OPEN: { target: 'opening' },\n      },\n    },\n\n    opening: {\n      entry: [startDelayTimer, setId, setDelayed],\n      exit: [cancelDelayTimer],\n      on: {\n        DELAY_TIMER_END: { target: 'open' },\n        CLOSE: { target: 'closed' },\n      },\n    },\n\n    open: {\n      entry: [setId],\n      exit: [resetDelayed],\n      on: {\n        OPEN: { target: 'open' },\n        CLOSE: {\n          target: 'closing',\n          cond: (context, event) => context.id === (event as any).id,\n        },\n      },\n    },\n\n    closing: {\n      entry: [startSkipDelayTimer],\n      exit: [cancelSkipDelayTimer],\n      on: {\n        OPEN: { target: 'open' },\n        SKIP_DELAY_TIMER_END: { target: 'closed' },\n      },\n    },\n  },\n};\n\nexport { tooltipStateChart };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine } from './createStateMachine';\nimport { tooltipStateChart } from './tooltipStateChart';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(tooltipStateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype ScopedProps<P> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope(TOOLTIP_NAME, [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onFocus(): void;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened.\n   * (default: 700)\n   */\n  delayDuration?: number;\n\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * (default: 300)\n   */\n  skipDelayDuration?: number;\n  children?: React.ReactNode;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    delayDuration = 700,\n    skipDelayDuration = 300,\n  } = props;\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'open' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (context.id === contentId) {\n        if (state === 'open') {\n          setStateAttribute(context.delayed ? 'delayed-open' : 'instant-open');\n        } else {\n          setStateAttribute('closed');\n        }\n      } else {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId]);\n\n  const handleFocus = React.useCallback(\n    () => stateMachine.send({ type: 'FOCUS', id: contentId }),\n    [contentId]\n  );\n  const handleOpen = React.useCallback(\n    () => stateMachine.send({ type: 'OPEN', id: contentId, delayDuration }),\n    [contentId, delayDuration]\n  );\n  const handleClose = React.useCallback(\n    () => stateMachine.send({ type: 'CLOSE', id: contentId, skipDelayDuration }),\n    [skipDelayDuration, contentId]\n  );\n\n  // send transition if the component unmounts\n  React.useEffect(() => () => handleClose(), [handleClose]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.send({ type: 'OPEN', id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onFocus={handleFocus}\n        onOpen={handleOpen}\n        onClose={handleClose}\n      >\n        {children}\n      </TooltipProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.onTriggerChange);\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          type=\"button\"\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedTriggerRef}\n          onMouseEnter={composeEventHandlers(props.onMouseEnter, context.onOpen)}\n          onMouseLeave={composeEventHandlers(props.onMouseLeave, context.onClose)}\n          onMouseDown={composeEventHandlers(props.onMouseDown, context.onClose)}\n          onFocus={composeEventHandlers(props.onFocus, context.onFocus)}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Enter' || event.key === ' ') {\n              context.onClose();\n            }\n          })}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    return (\n      <Presence present={forceMount || context.open}>\n        <TooltipContentImpl ref={forwardedRef} {...contentProps} />\n      </Presence>\n    );\n  }\n);\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends PopperContentProps {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Whether the Tooltip should render in a Portal\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      portalled = true,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n\n    useEscapeKeydown(() => context.onClose());\n\n    return (\n      <PortalWrapper>\n        <CheckTriggerMoved __scopeTooltip={__scopeTooltip} />\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom property\n            ['--radix-tooltip-content-transform-origin' as any]:\n              'var(--radix-popper-transform-origin)',\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n            {ariaLabel || children}\n          </VisuallyHiddenPrimitive.Root>\n        </PopperPrimitive.Content>\n      </PortalWrapper>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved(props: ScopedProps<{}>) {\n  const { __scopeTooltip } = props;\n  const context = useTooltipContext('CheckTriggerMoved', __scopeTooltip);\n\n  const triggerRect = useRect(context.trigger);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n  const handleClose = context.onClose;\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      handleClose();\n    }\n  }, [handleClose, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\nexport type { TooltipProps, TooltipTriggerProps, TooltipContentProps, TooltipArrowProps };\n"]},"metadata":{},"sourceType":"module"}