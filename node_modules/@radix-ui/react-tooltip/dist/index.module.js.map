{"mappings":"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","sources":["./packages/react/tooltip/src/createStateMachine.tsx","./packages/react/tooltip/src/tooltipStateChart.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["const ASSIGN_ACTION_TYPE = 'machine.actions.assign' as const;\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\ntype StateChart<State extends string, Context, Event extends { type: string }> = {\n  initial: State;\n  context: Context;\n  on?: {\n    [eventType in Event['type']]?: Transition<State, Context, Event>;\n  };\n  states: {\n    [stateValue in State]: {\n      on?: {\n        [eventType in Event['type']]?: Transition<State, Context, Event>;\n      };\n      entry?: Array<Action<Context, Event>>;\n      exit?: Array<Action<Context, Event>>;\n    };\n  };\n};\n\ntype Transition<State extends string, Context, Event> = {\n  target?: State;\n  actions?: Array<Action<Context, Event>>;\n  cond?: (context: Context, Event: Event) => boolean;\n};\n\ntype Action<Context, Event> = ActionFunction<Context, Event> | AssignAction<Context, Event>;\n\ntype ActionFunction<Context, Event> = (\n  context: Context,\n  event: Event,\n  send: (event: Event) => void\n) => void;\n\nfunction createStateMachine<State extends string, Context, Event extends { type: string }>(\n  stateChart: StateChart<State, Context, Event>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let currentState = stateChart.initial;\n  let currentContext = stateChart.context;\n\n  type CallbackFn = (args: { state: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) => callback({ state: currentState, context: currentContext }));\n  }\n\n  const send = (event: Event) => {\n    const stateDefinition = stateChart.states[currentState];\n    const type: Event['type'] | undefined = event.type;\n    const topLevelTransition: Transition<State, Context, Event> | undefined = stateChart.on?.[type];\n    const stateTransition: Transition<State, Context, Event> | undefined =\n      stateDefinition.on?.[type];\n    const transition = topLevelTransition ?? stateTransition;\n\n    if (transition === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(\n          `From state: \"${currentState}\", event \"${type}\" has no transition to any state`\n        );\n      }\n    } else {\n      const { target: nextState, actions = [], cond = () => true } = transition;\n      const nextStateDefinition = nextState ? stateChart.states[nextState] : {};\n\n      if (cond(currentContext, event)) {\n        // execute actions\n        const allActions = (stateDefinition.exit || []).concat(\n          actions,\n          nextStateDefinition.entry || []\n        );\n        currentContext = executeActions(allActions, event, currentContext);\n\n        if (nextState) {\n          currentState = nextState;\n\n          if (debug) {\n            console.group('event:', event);\n            console.log('state:', currentState);\n            console.log('context:', currentContext);\n            console.groupEnd();\n          }\n\n          notify();\n        }\n      }\n    }\n  };\n\n  function getContext() {\n    return currentContext;\n  }\n\n  function executeActions(\n    actions: Array<Action<Context, Event>>,\n    event: Event,\n    context: Context\n  ): Context {\n    let nextContext = context;\n    actions?.forEach((action) => {\n      if (typeof action === 'function') {\n        action(nextContext, event, send);\n      } else if (action.type === ASSIGN_ACTION_TYPE) {\n        nextContext = action.assign(nextContext, event);\n      }\n    });\n    return nextContext;\n  }\n\n  return { subscribe, send, getContext };\n}\n\ntype AssignAction<Context, Event> = {\n  type: typeof ASSIGN_ACTION_TYPE;\n  assign(context: Context, event: Event): Context;\n};\n\nfunction assign<Context, Event>(\n  assignFn: AssignAction<Context, Event>['assign']\n): AssignAction<Context, Event> {\n  return { type: ASSIGN_ACTION_TYPE, assign: assignFn };\n}\n\nexport { createStateMachine, assign };\nexport type { StateChart, Action };\n","import { assign } from './createStateMachine';\n\nimport type { StateChart, Action } from './createStateMachine';\n\ntype TooltipState = 'closed' | 'opening' | 'open' | 'closing';\n\ntype TooltipEvent =\n  | { type: 'OPEN'; id: string; delayDuration?: number }\n  | { type: 'CLOSE'; id: string; skipDelayDuration: number }\n  | { type: 'FOCUS'; id: string }\n  | { type: 'DELAY_TIMER_END' }\n  | { type: 'SKIP_DELAY_TIMER_END' };\n\ntype TooltipContext = { id: string | null; delayed: boolean };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipContext, TooltipEvent>;\ntype TooltipAction = Action<TooltipContext, TooltipEvent>;\n\n// actions\nlet delayTimerId: number;\nlet skipDelayTimerId: number;\n\nconst startDelayTimer: TooltipAction = (context, event, send) => {\n  const delayDuration: number | undefined = (event as any).delayDuration;\n  const sendTimerEnd = () => send({ type: 'DELAY_TIMER_END' });\n  if (delayDuration === undefined) {\n    sendTimerEnd();\n  } else {\n    delayTimerId = window.setTimeout(sendTimerEnd, delayDuration);\n  }\n};\n\nconst cancelDelayTimer: TooltipAction = () => clearTimeout(delayTimerId);\n\nconst startSkipDelayTimer: TooltipAction = (context, event, send) => {\n  const skipDelayDuration: number = (event as any).skipDelayDuration ?? 300;\n  skipDelayTimerId = window.setTimeout(\n    () => send({ type: 'SKIP_DELAY_TIMER_END' }),\n    skipDelayDuration\n  );\n};\n\nconst cancelSkipDelayTimer: TooltipAction = () => clearTimeout(skipDelayTimerId);\n\nconst setId: TooltipAction = assign((context, event) => ({\n  ...context,\n  id: (event as any).id ?? context.id,\n}));\nconst resetId: TooltipAction = assign((context) => ({ ...context, id: null }));\nconst setDelayed: TooltipAction = assign((context) => ({ ...context, delayed: true }));\nconst resetDelayed: TooltipAction = assign((context) => ({ ...context, delayed: false }));\n\nconst tooltipStateChart: TooltipStateChart = {\n  initial: 'closed',\n  context: { id: null, delayed: false },\n  on: {\n    FOCUS: { target: 'open' },\n  },\n  states: {\n    closed: {\n      entry: [resetId],\n      on: {\n        OPEN: { target: 'opening' },\n      },\n    },\n\n    opening: {\n      entry: [startDelayTimer, setId, setDelayed],\n      exit: [cancelDelayTimer],\n      on: {\n        DELAY_TIMER_END: { target: 'open' },\n        CLOSE: { target: 'closed' },\n      },\n    },\n\n    open: {\n      entry: [setId],\n      exit: [resetDelayed],\n      on: {\n        OPEN: { target: 'open' },\n        CLOSE: {\n          target: 'closing',\n          cond: (context, event) => context.id === (event as any).id,\n        },\n      },\n    },\n\n    closing: {\n      entry: [startSkipDelayTimer],\n      exit: [cancelSkipDelayTimer],\n      on: {\n        OPEN: { target: 'open' },\n        SKIP_DELAY_TIMER_END: { target: 'closed' },\n      },\n    },\n  },\n};\n\nexport { tooltipStateChart };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine } from './createStateMachine';\nimport { tooltipStateChart } from './tooltipStateChart';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(tooltipStateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype ScopedProps<P> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope(TOOLTIP_NAME, [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onFocus(): void;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened.\n   * (default: 700)\n   */\n  delayDuration?: number;\n\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * (default: 300)\n   */\n  skipDelayDuration?: number;\n  children?: React.ReactNode;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    delayDuration = 700,\n    skipDelayDuration = 300,\n  } = props;\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'open' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (context.id === contentId) {\n        if (state === 'open') {\n          setStateAttribute(context.delayed ? 'delayed-open' : 'instant-open');\n        } else {\n          setStateAttribute('closed');\n        }\n      } else {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId]);\n\n  const handleFocus = React.useCallback(\n    () => stateMachine.send({ type: 'FOCUS', id: contentId }),\n    [contentId]\n  );\n  const handleOpen = React.useCallback(\n    () => stateMachine.send({ type: 'OPEN', id: contentId, delayDuration }),\n    [contentId, delayDuration]\n  );\n  const handleClose = React.useCallback(\n    () => stateMachine.send({ type: 'CLOSE', id: contentId, skipDelayDuration }),\n    [skipDelayDuration, contentId]\n  );\n\n  // send transition if the component unmounts\n  React.useEffect(() => () => handleClose(), [handleClose]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.send({ type: 'OPEN', id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onFocus={handleFocus}\n        onOpen={handleOpen}\n        onClose={handleClose}\n      >\n        {children}\n      </TooltipProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.onTriggerChange);\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          type=\"button\"\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedTriggerRef}\n          onMouseEnter={composeEventHandlers(props.onMouseEnter, context.onOpen)}\n          onMouseLeave={composeEventHandlers(props.onMouseLeave, context.onClose)}\n          onMouseDown={composeEventHandlers(props.onMouseDown, context.onClose)}\n          onFocus={composeEventHandlers(props.onFocus, context.onFocus)}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Enter' || event.key === ' ') {\n              context.onClose();\n            }\n          })}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n    return (\n      <Presence present={forceMount || context.open}>\n        <TooltipContentImpl ref={forwardedRef} {...contentProps} />\n      </Presence>\n    );\n  }\n);\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends PopperContentProps {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Whether the Tooltip should render in a Portal\n   * (default: `true`)\n   */\n  portalled?: boolean;\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      portalled = true,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const PortalWrapper = portalled ? Portal : React.Fragment;\n\n    useEscapeKeydown(() => context.onClose());\n\n    return (\n      <PortalWrapper>\n        <CheckTriggerMoved __scopeTooltip={__scopeTooltip} />\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom property\n            ['--radix-tooltip-content-transform-origin' as any]:\n              'var(--radix-popper-transform-origin)',\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n            {ariaLabel || children}\n          </VisuallyHiddenPrimitive.Root>\n        </PopperPrimitive.Content>\n      </PortalWrapper>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved(props: ScopedProps<{}>) {\n  const { __scopeTooltip } = props;\n  const context = useTooltipContext('CheckTriggerMoved', __scopeTooltip);\n\n  const triggerRect = useRect(context.trigger);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n  const handleClose = context.onClose;\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      handleClose();\n    }\n  }, [handleClose, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\nexport type { TooltipProps, TooltipTriggerProps, TooltipContentProps, TooltipArrowProps };\n"],"names":["assign","assignFn","type","delayTimerId","skipDelayTimerId","setId","$ef54466d8a95ecaa234e3ec978fbe68$export$assign","context","event","_id","id","stateMachine","stateChart","debug","warnOnUnknownTransitions","currentState","initial","currentContext","subscriptions","send","_stateChart$on","_stateDefinition$on","stateDefinition","states","topLevelTransition","on","stateTransition","transition","undefined","console","warn","target","nextState","actions","cond","nextStateDefinition","allActions","exit","concat","entry","nextContext","forEach","action","executeActions","group","log","groupEnd","callback","state","subscribe","push","splice","indexOf","getContext","$ef54466d8a95ecaa234e3ec978fbe68$export$createStateMachine","delayed","FOCUS","closed","OPEN","opening","delayDuration","sendTimerEnd","window","setTimeout","clearTimeout","DELAY_TIMER_END","CLOSE","open","closing","_skipDelayDuration","skipDelayDuration","SKIP_DELAY_TIMER_END","createTooltipContext","createTooltipScope","createContextScope","createPopperScope","usePopperScope","TooltipProvider","useTooltipContext","Tooltip","props","__scopeTooltip","children","openProp","defaultOpen","onOpenChange","popperScope","trigger","setTrigger","React","useState","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useEffect","handleFocus","useCallback","handleOpen","handleClose","useLayoutEffect","_react","createElement","_radixUiReactPopper","Root","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","scope","onTriggerChange","onFocus","onOpen","onClose","TooltipTrigger","forwardRef","forwardedRef","triggerProps","composedTriggerRef","useComposedRefs","Anchor","_babelRuntimeHelpersEsmExtends","asChild","Primitive","button","ref","onMouseEnter","composeEventHandlers","onMouseLeave","onMouseDown","onBlur","onKeyDown","key","TooltipContent","forceMount","contentProps","Presence","present","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","portalled","PortalWrapper","Portal","Fragment","useEscapeKeydown","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","Content","style","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","arrowProps","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger"],"version":3,"file":"index.module.js.map"}